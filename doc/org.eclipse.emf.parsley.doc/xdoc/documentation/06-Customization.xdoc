chapter:Customizations[Customizations]

In this chapter we will describe how e[EMF Parsley] let you customize the standard behaviours.
A DSL is provided to easily customize most common feature, but you can customize all aspect by doing
manually. As a matter of fact each customization is explained in a single section, with the details on the DSL (if available) and the
class for overriding by Java.

As we deeply explained in the ref:Introduction, if you wnat to provide a specific implementation via
Java, you can use the Google Guice injection mechanism, buy overriding the specific class with your own
implementation. Note that an explicit contructor is needed, with the e[@Inject] annotation to make Guice
correctly works.

section:Providers[Providers]


section2:ViewerLabelProvider[Viewer Label Provider]

The Label Prorvider as in JFace allows to specify the representation of a given Object. e[EMF Parsley]
provides an implementation that uses the information provided via the DSL, as you can see in the snippet
below. 

code[EmfParsley][labelProvider{
	text{
		Book -> "Book:"+title
		Borrower -> "Borrower: "+firstName
	}
	image{
		Book -> "book.png"
	}
}
]

However if you wnat to use your own implementation, you can do that by providing a specific implementation of codeRef[org.eclipse.jface.viewers.ILabelProvider]
and injecting it in the spefic module e[(TODO)].
e[EMF Parsley] provides such an implementation with the class codeRef[org.eclipse.emf.parsley.ui.provider.ViewerLabelProvider]
that is inteded to be surclassed by the programmer to provides specific implementations like in the example below.

code[Java][
public class CustomLibraryLabelProvider extends ViewerLabelProvider {

	@Inject
	public CustomLibraryLabelProvider(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	public String text(Book book) {
		return "Book: " + book.getTitle();
	}

	public String image(Book book) {
		return "book.png";
	}

	public String text(Borrower b) {
		return "Borrower: " + b.getFirstName();
	}
}
]

section2:ViewerContentProvider[Viewer Content Provider]

As in Jface, the Content Provider is used to get the elements to represent and for tree their children.
e[EMF Parsley] provides an implementation that uses the DSL as in the code below.

code[EmfParsley][viewerContentProvider{
	elements{
		Library -> books
	}
	children{
		Library -> books
		Book b-> {
			new ArrayList()=>\[
				add(b.author)
				addAll(b.borrowers)
			\]
		}
	}
}]


The developer can also provide a specific implementation of codeRef[org.eclipse.jface.viewers.IContentProvider]
by injecting it in the spefic module e[(TODO)]. EMF Parsley provides an implementation with the class
codeRef[org.eclipse.emf.parsley.edit.ui.provider.ViewerContentProvider] that can be easily used to
specify the children of all object on the tree, like in the example below.

code[Java][
public class CustomLibraryViewerContentProvider extends ViewerContentProvider {

	@Inject
	public CustomLibraryViewerContentProvider(AdapterFactory adapterFactory) {
		super(adapterFactory);
	}

 	public Object elements(Library library) {
    	return library.getBooks();
  	}

	public Object children(Library library) {
		return library.getBooks();
	}

	public Object children(Book book) {
		ArrayList<Object> children = new ArrayList<Object>();
		Writer author = book.getAuthor();
		if (author != null) {
			children.add(author);
		}
		children.addAll(book.getBorrowers());
		return children;
	}
}
]

section2:FeaturesProvider[Features Provider]

e[EMF Parsley] uses thi kinf of provider wherever a list of feature is requested for a certain EClass.
The default is to return the list of all the features in the EClass, but the programmer can customize it (for instance,
by returning only a superset, or using a different order) on an EClass-based strategy.
Thus you can use the DSL to specify that list, as in the snipped below.

code[EmfParsley][featuresProvider{
	features{
		Book -> title, author, category, pages 		
	}
}] 
 
If we look at Java, there are more chances to customize this behaviour, but we need to go deep in some
details of the e[Feature Provider] implementation. 

When the framework builds components according to the
codeRef[org.eclipse.emf.ecore.EStructuralFeature]s of a given
codeRef[org.eclipse.emf.ecore.EClass] it relies on an injected
codeRef[org.eclipse.emf.parsley.ui.provider.FeaturesProvider].
The default behavior is to simply return all the features of the a given EClass,
in the order they are defined in the EClass, as implemented by the method e[defaultFeatures] in codeRef[org.eclipse.emf.parsley.ui.provider.FeaturesProvider].

You can set the mappings, i.e., specify the structural
features you want to be used given an EClass, by implementing
the method e[buildMap], which receives the
codeRef[org.eclipse.emf.parsley.ui.provider.FeaturesProvider$EClassToEStructuralFeatureMap]
that can be filled with the method e[mapTo]; 
for instance, using the EMF extended library
example, this customization will return only the e[name] and e[address] features
for e[Library], the e[firstName], e[lastName] and e[address] for
e[Person], and the e[firstName], e[lastName] and e[books] (but
not e[address]) for e[Writer] (which inherits from e[Person]).

code[Java][
import static org.eclipse.emf.examples.extlibrary.EXTLibraryPackage.Literals.*;
import org.eclipse.emf.parsley.ui.provider.EStructuralFeaturesProvider;

public class LibraryEStructuralFeaturesProvider extends
		FeaturesProvider {

	@Override
	protected void buildMap(EClassToEStructuralFeatureMap map) {
		super.buildMap(map);
		map.mapTo(LIBRARY,
				LIBRARY__NAME, ADDRESSABLE__ADDRESS);
		map.mapTo(PERSON, PERSON__FIRST_NAME, PERSON__LAST_NAME, ADDRESSABLE__ADDRESS);
		map.mapTo(WRITER, PERSON__FIRST_NAME, PERSON__LAST_NAME, WRITER__BOOKS);
	}
}
]

Another possibility is to build a map which relies on Strings
both for the codeRef[org.eclipse.emf.ecore.EClass] and for
the list of codeRef[org.eclipse.emf.ecore.EStructuralFeature];
note that the name of the codeRef[org.eclipse.emf.ecore.EClass] should
be obtained by using e[getInstanceClassName()]; you can also
combine the two approaches.


section3:TableFeaturesProvider[Table Features Provider]

As an extension, you can use the codeRef[org.eclipse.emf.parsley.ui.provider.TableFeaturesProvider]:
the customizations will be applied only to ref:TableComponent[Tables], not to ref:FormComponent[Forms].


section2:FeatureCaptionProvider[Feature Caption Provider]

The codeRef[org.eclipse.emf.parsley.ui.provider.FeatureCaptionProvider] provides captions for
the features in ref:TableComponent[Tables] and ref:FormComponent[Forms].
Here you can see an example of the DSL.
 
code[EmfParsley][featureCaptionProvider{
	text{
		Book:author -> "Wrote by:"
		Writer:name -> "Name:"
	}
}]
 
The codeRef[org.eclipse.emf.parsley.ui.provider.FeatureCaptionProvider] provides captions for
the features. It can be customized, with injection (see Injection paragraph), to customize the caption label on the
left of each control in a form and the headers in a table's columns. 
The framework use a polimorphic mechanism to find customizations, so that It can
be written a method with a specific signature build by the keyword e['text'] followed by the EClass and the EStructuralFeature.
All parts of the name are separated by an underscore character and the method must accept a parameter of type EStructuralFeature.

In the following example we specify the caption text for the feature 'Author' of Book and the feature 'Name' for
Writer.

code[Java][
public String text_Book_author(final EStructuralFeature feature) {
	return "Wrote by:";
}

public String text_Writer_name(final EStructuralFeature feature) {
	return "Name:";
}
] 

section3:FormFeatureCaptionProvider[Form Feature Caption Provider]

The codeRef[org.eclipse.emf.parsley.ui.provider.FormFeatureCaptionProvider] can be used if you want
to define the description only for the form. For example using the ref:TreeFormComponent[Tree
Form] your definition will not be used in the tree.

In this case you can also define a method the returns directly the control, like in the example
below. In such methods there is another parameter that is the parent composite.

code[Java][
public Label label_Writer_name(Composite parent, EStructuralFeature feature) {
	Label label = defaultLabel(parent, feature);
	label.setBackground(getFormToolkit().getColors().getColor(IFormColors.TITLE));
	return label;
}
]

section2:ProposalProvider[Proposal Provider]

Some controls use a list of proposal to help the end user experince: for example the combo box has a
list of proposal, but also the simple text can use the proposal to assist and correct the hand-writed
values. For each feature it can be specified a list of proposals via the DSl.

code[EmfParsley][proposals{
	Book:author -> {
		defaultProposals(feature).
			filter(Writer).
			filter\[name.startsWith("F")\].toList
	}
}]
 
This customization can be done also in Java, by extending the class codeRef[org.eclipse.emf.parsley.binding.ProposalCreator]
and implementing the method code[Java][public List<?> proposals_Book_author(Book book) {...}].

section:ContextualMenu[Contextual Menu]

Contextual menu can be added to any viewer by usinf the codeRef[org.eclipse.emf.parsley.viewers.ViewerInitializer]. 

code[Java][@Inject ViewerInitializer viewerInitializer;
(...)

treeActionBarContributor.initialize(editingDomain);
viewerInitializer.addContextMenu(treeFormComposite.getViewer(),
treeActionBarContributor, editingDomain, this);
treeFormComposite.getViewer().addSelectionChangedListener(treeActionBarContributor);]


section2:MenuBuilder[Menu Builder]

e[EMF Parsley] logically separate the menu into 2 parts. The first section contains all common edit commands
such as e[copy] and e[paste]. The second section regards EMF specific commands, such as for example e[new child].
You can use the DSL to fully customize the menu, as in the example below. 

code[EmfParsley][menuBuilder{
	menus{
		Library-> #\[
			submenu("Edit",#\[
				actionCopy,
				actionCut,
				separator,
				actionPaste
			\])
		\]
	}
	emfMenus{
		Library -> #\[
			actionAdd("Add a new book", books,
				EXTLibraryFactory.eINSTANCE.createBook => \[
					title="new book"
				\]
			)
		\]
	}
}]

You can customize menu also via Java, by extending the codeRef[org.eclipse.emf.parsley.edit.action.EditingMenuBuilder].


section:Factories[Factories]


section2:FormControlFactory[Form Control Factory]

 e[EMF Parsley] let you customize the e[form controls] via the DSL as in the following example.
 
 code[EmfParsley][formControlFactory {
	control {
		Library : name -> { }
		Writer : books -> 
			createLabel(
				books.map\[title\].join(", "))
		Writer : name -> { createLabel(parent, "") }
			target { observeText }
		Writer : firstName -> 
			toolkit.createLabel(parent, "")
			target observeText(SWT::Modify)
		Borrower : firstName -> {
			createText(firstName, SWT::MULTI, SWT::BORDER,
								SWT::WRAP, SWT::V_SCROLL)
		}
	}
}]
 
If you want to customize the controls on the detail via Java, you can extend the class codeRef[org.eclipse.emf.parsley.binding.FormControlFactory].
Using the same polimorphic mechanism of the labels, the programmer can write a method with the keyword e['control']
followed by the EClass and EStructuralFeature undescore-character-separated. In the signature of the
method must be both the e[DataBinding Context] and the e[Feature Observable] that can be used for databinding. 

code[Java][
public Control control_Writer_name(DataBindingContext dbc,IObservableValue featureObservable) {
	//Creating the control
	Text text = getToolkit().createText(getParent(), "");
	text.setData(FormToolkit.KEY_DRAW_BORDER, FormToolkit.TREE_BORDER);
	text.setBackground(getToolkit().getColors().getColor(IFormColors.TITLE));
	//Binding the control to the feature observable
	dbc.bindValue(SWTObservables.observeText(text, SWT.Modify),	featureObservable);
	return text;
}
]

section2:DialogControFactory[Dialog Control Factory]

If you want to customize controls in Dialog, you can use the specific DSL section e[dialogControlFactory]: 

code[EmfParsley][dialogControlFactory {
	control {
		...
	}
}]
